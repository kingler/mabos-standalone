import os
import yaml
from typing import List
import uuid
import os
from typing import List, Any, Dict
from pydantic import BaseModel, Field, SkipValidation
from app.core.models.agent.goal import Goal
from app.core.tools.llm_manager import LLMManager
from dotenv import load_dotenv

load_dotenv()

class LLMDecomposer(BaseModel):
    config: Dict[str, Any] = Field(default_factory=SkipValidation)
    llm_manager: LLMManager = Field(default_factory=SkipValidation)
    
    def __init__(self, config_path='/Users/kinglerbercy/Projects/Apps/mas-repo/mabos-standalone/config/llm_config.yaml'):
        super().__init__()
        # Load environment variables
        api_key = os.getenv('API_KEY')
        if not api_key:
            raise ValueError("API_KEY not found in environment variables")
        
        # Load configuration file
        self.config = self.load_config(config_path)
        
        # Debugging: Print the configuration before using it
        print("Loaded configuration in LLMDecomposer:", self.config)
        
        # Check if 'llms' key exists in the config
        if 'llms' not in self.config:
            raise KeyError("'llms' key not found in the configuration file")
        
        # Initialize LLMManager
        self.llm_manager = LLMManager(llms_config=self.config['llms'], api_key=api_key)

    def load_config(self, config_path):
        if not os.path.exists(config_path):
            raise FileNotFoundError(f"Configuration file not found: {config_path}")
        
        with open(config_path, 'r') as config_file:
            config = yaml.safe_load(config_file)
        
        # Debugging: Print the configuration
        print("Loaded configuration:", config)
        
        # Check if 'llms' key exists in the config
        if 'llms' not in config:
            raise KeyError("'llms' key not found in the configuration file")
        
        return config

    def decompose(self, goal: Goal) -> List[Goal]:
        """
        Decompose a high-level goal into 3-5 specific, actionable subgoals using a Large Language Model (LLM).

        Args:
            goal (Goal): The high-level goal to be decomposed.

        Returns:
            List[Goal]: A list of subgoals generated by the LLM.
        """
        prompt = self._create_prompt(goal)
        response = self.llm_manager.get_text_completion(prompt)
        subgoals = self._parse_response(response, goal.priority)
        return subgoals

    def _create_prompt(self, goal: Goal) -> str:
        return f"""
        Given the following high-level goal:
        
        "{goal.description}"
        
        Please decompose this goal into 3-5 specific, actionable subgoals. Each subgoal should be a clear, concise step towards achieving the main goal. Format your response as a numbered list, with each subgoal on a new line.
        
        For example:
        1. [Subgoal 1 description]
        2. [Subgoal 2 description]
        3. [Subgoal 3 description]
        ...
        
        Please provide the subgoals now:
        """

    def _parse_response(self, response: str, parent_priority: int) -> List[Goal]:
        subgoals = []
        lines = response.split('\n')
        for line in lines:
            if line.strip() and line[0].isdigit():
                description = line.split('.', 1)[1].strip()
                subgoal = Goal(
                    id=str(uuid.uuid4()),
                    description=description,
                    priority=max(1, parent_priority - 1),
                    llm_generated_context="Generated as a subgoal by LLMDecomposer"
                )
                subgoals.append(subgoal)
        return subgoals

    def validate_subgoals(self, main_goal: Goal, subgoals: List[Goal]) -> List[Goal]:
        subgoal_descriptions = "\n".join([f"{i+1}. {sg.description}" for i, sg in enumerate(subgoals)])
        validation_prompt = f"""
        Main Goal: {main_goal.description}
        
        Subgoals:
        {subgoal_descriptions}
        
        Please validate these subgoals. Ensure they are:
        1. Relevant to the main goal
        2. Specific and actionable
        3. Collectively comprehensive in achieving the main goal
        
        If any subgoals do not meet these criteria, please suggest improvements or replacements. 
        If all subgoals are valid, simply respond with "All subgoals are valid."
        
        Your response:
        """

        validation_response = self.llm_manager.get_text_completion(validation_prompt)

        if "All subgoals are valid" in validation_response:
            return subgoals
        else:
            for subgoal in subgoals:
                subgoal.llm_generated_context += f"\nValidation feedback: {validation_response}"
            return subgoals

    def decompose_with_validation(self, goal: Goal) -> List[Goal]:
        initial_subgoals = self.decompose(goal)
        validated_subgoals = self.validate_subgoals(goal, initial_subgoals)
        return validated_subgoals