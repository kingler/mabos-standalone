---
component: repositories
description: Contains data access layer and repository pattern implementations for MABOS
main-technologies:
  - Python
  - SQLAlchemy (if used)
  - ArangoDB Python driver
conventions:
  - Use repository pattern for data access
  - Implement CRUD operations for each entity
  - Keep business logic separate from data access logic
---

# Repositories Component

This directory implements the repository pattern for MABOS, providing a clean separation between the data access layer and the rest of the application. It encapsulates the logic required to access data sources.

## Structure

- `__init__.py`: Initialization and common utilities
- `models/`: Contains specific model repositories
  - `goal_objective_service_diagram.xml`: XML representation of goal and objective models
  - `state_machine_uml.xml`: UML representation of state machines
- `ontologies/`: Repository for ontology-related data access
- `rules/`: Repository for accessing and managing business rules
  - `rules.csv`: CSV file containing business rules
  - `rules.xml`: XML representation of business rules

## Key Responsibilities

1. Abstracting data access logic from business logic
2. Providing CRUD operations for different entities
3. Implementing complex queries and data manipulations
4. Managing transactions and ensuring data consistency

## Development Guidelines

- Implement a base repository class with common CRUD operations
- Use dependency injection to provide database sessions to repositories
- Keep repository methods focused on data access, moving business logic to services
- Use clear and consistent naming for repository methods

## Repository Implementation

When implementing a new repository:
- Create a new file for each entity or closely related group of entities
- Implement standard CRUD operations (create, read, update, delete)
- Add methods for any complex queries or data manipulations specific to the entity
- Use type hints and docstrings for better code readability and maintainability

## Query Optimization

- Use database-specific features for complex queries when necessary
- Implement caching strategies for frequently accessed, rarely changing data
- Use lazy loading and eager loading appropriately to optimize database queries

## Testing Repositories

- Implement unit tests for each repository method
- Use an in-memory database or test database for running repository tests
- Test both successful operations and error cases

## Usage Example

```python
from app.repositories.user_repository import UserRepository

async def get_user_by_email(email: str):
    user_repo = UserRepository()
    user = await user_repo.get_by_email(email)
    return user
```

Remember to update the `README.md` in this directory with any significant changes to the repository structure or when adding new repositories.